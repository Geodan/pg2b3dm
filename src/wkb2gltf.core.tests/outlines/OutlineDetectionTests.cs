using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using NUnit.Framework;
using SharpGLTF.Geometry.VertexTypes;
using SharpGLTF.Geometry;
using SharpGLTF.Materials;
using SharpGLTF.Scenes;
using Wkb2Gltf.extensions;
using Wkb2Gltf.outlines;
using Wkx;
using Wkb2Gltf.Extensions;

namespace Wkb2Gltf.Tests.outlines;
public class OutlineDetectionTests
{
    static bool DrawTriangle(Triangle triangle, MaterialBuilder material, MeshBuilder<VertexPositionNormal, VertexWithBatchId, VertexEmpty> mesh)
    {
        var normal = triangle.GetNormal();
        var prim = mesh.UsePrimitive(material);
        var vectors = triangle.ToVectors();
        var indices = prim.AddTriangleWithBatchId(vectors, normal, 0);
        return indices.Item1 > 0;
    }

    [Test]
    public void OutlineDetectionTest()
    {
        // arrange
        var t0 = new Triangle(new Point(0, 0, 0), new Point(0, 1, 0), new Point(1, 0, 0), 0);
        var t1 = new Triangle(new Point(1, 0, 0), new Point(0, 1, 0), new Point(1, 1, 0), 1);
        var t2 = new Triangle(new Point(10, 0, 0), new Point(10, 1, 0), new Point(11, 1, 0), 2);

        // put them in wrong order
        var triangles = new List<Triangle> { t0, t2, t1 };

        var parts = PartFinder.GetParts(triangles);

        // Now we expect 2 parts: {t0, t1} connected and {t2} separate
        Assert.That(parts.Count, Is.EqualTo(2));
        Assert.That(parts[0].Count, Is.EqualTo(2));
        Assert.That(parts[1].Count, Is.EqualTo(1));

        var outlines = OutlineDetection.GetOutlines2(triangles);
        // Part 0 (t0+t1 square): 4 edges = 8 indices
        // Part 1 (t2 triangle): 3 edges = 6 indices
        // Total: 14 indices
        Assert.That(outlines.Count, Is.EqualTo(14));
    }

    [Test]
    public void Test5415()
    {
        var wkt = "POLYHEDRALSURFACE Z (((1241911.54902145 -4797217.68794191 4002129.80061267,1241918.89248214 -4797221.19512978 4002123.36128067,1241903.14171574 -4797224.93080186 4002123.76836904,1241911.54902145 -4797217.68794191 4002129.80061267)),((1241905.58223567 -4797232.68949606 4002113.7782439,1241910.55433709 -4797228.46255695 4002117.27846764,1241909.57001823 -4797234.5929178 4002110.28275577,1241905.58223567 -4797232.68949606 4002113.7782439)),((1241926.11534648 -4797219.8875908 4002122.69172965,1241909.57001823 -4797234.5929178 4002110.28275577,1241922.43981354 -4797218.13296293 4002125.9138087,1241926.11534648 -4797219.8875908 4002122.69172965)),((1241903.14171574 -4797224.93080186 4002123.76836904,1241918.89248214 -4797221.19512978 4002123.36128067,1241910.55433709 -4797228.46255695 4002117.27846764,1241903.14171574 -4797224.93080186 4002123.76836904)),((1241909.57001823 -4797234.5929178 4002110.28275577,1241910.55433709 -4797228.46255695 4002117.27846764,1241922.43981354 -4797218.13296293 4002125.9138087,1241909.57001823 -4797234.5929178 4002110.28275577)),((1241922.43981354 -4797218.13296293 4002125.9138087,1241918.89248214 -4797221.19512978 4002123.36128067,1241910.55433709 -4797228.46255695 4002117.27846764,1241922.43981354 -4797218.13296293 4002125.9138087)),((1241913.96414361 -4797227.01700145 4002137.63593226,1241921.3076186 -4797230.52419617 4002131.19658769,1241905.55682157 -4797234.25987552 4002131.60367685,1241913.96414361 -4797227.01700145 4002137.63593226)),((1241907.99734626 -4797242.01858487 4002121.61353221,1241912.96945734 -4797237.79163751 4002125.11376279,1241911.98513658 -4797243.92201033 4002118.11803725,1241907.99734626 -4797242.01858487 4002121.61353221)),((1241928.53049699 -4797229.21665466 4002130.52703536,1241911.98513658 -4797243.92201033 4002118.11803725,1241924.85495689 -4797227.46202335 4002133.7491207,1241928.53049699 -4797229.21665466 4002130.52703536)),((1241905.55682157 -4797234.25987552 4002131.60367685,1241921.3076186 -4797230.52419617 4002131.19658769,1241912.96945734 -4797237.79163751 4002125.11376279,1241905.55682157 -4797234.25987552 4002131.60367685)),((1241911.98513658 -4797243.92201033 4002118.11803725,1241912.96945734 -4797237.79163751 4002125.11376279,1241924.85495689 -4797227.46202335 4002133.7491207,1241911.98513658 -4797243.92201033 4002118.11803725)),((1241924.85495689 -4797227.46202335 4002133.7491207,1241921.3076186 -4797230.52419617 4002131.19658769,1241912.96945734 -4797237.79163751 4002125.11376279,1241924.85495689 -4797227.46202335 4002133.7491207)),((1241918.89248214 -4797221.19512978 4002123.36128067,1241921.3076186 -4797230.52419617 4002131.19658769,1241922.43981354 -4797218.13296293 4002125.9138087,1241918.89248214 -4797221.19512978 4002123.36128067)),((1241924.85495689 -4797227.46202335 4002133.7491207,1241922.43981354 -4797218.13296293 4002125.9138087,1241921.3076186 -4797230.52419617 4002131.19658769,1241924.85495689 -4797227.46202335 4002133.7491207)),((1241922.43981354 -4797218.13296293 4002125.9138087,1241924.85495689 -4797227.46202335 4002133.7491207,1241926.11534648 -4797219.8875908 4002122.69172965,1241922.43981354 -4797218.13296293 4002125.9138087)),((1241928.53049699 -4797229.21665466 4002130.52703536,1241926.11534648 -4797219.8875908 4002122.69172965,1241924.85495689 -4797227.46202335 4002133.7491207,1241928.53049699 -4797229.21665466 4002130.52703536)),((1241911.98513658 -4797243.92201033 4002118.11803725,1241909.57001823 -4797234.5929178 4002110.28275577,1241926.11534648 -4797219.8875908 4002122.69172965,1241911.98513658 -4797243.92201033 4002118.11803725)),((1241926.11534648 -4797219.8875908 4002122.69172965,1241928.53049699 -4797229.21665466 4002130.52703536,1241911.98513658 -4797243.92201033 4002118.11803725,1241926.11534648 -4797219.8875908 4002122.69172965)),((1241909.57001823 -4797234.5929178 4002110.28275577,1241911.98513658 -4797243.92201033 4002118.11803725,1241905.58223567 -4797232.68949606 4002113.7782439,1241909.57001823 -4797234.5929178 4002110.28275577)),((1241907.99734626 -4797242.01858487 4002121.61353221,1241905.58223567 -4797232.68949606 4002113.7782439,1241911.98513658 -4797243.92201033 4002118.11803725,1241907.99734626 -4797242.01858487 4002121.61353221)),((1241905.58223567 -4797232.68949606 4002113.7782439,1241907.99734626 -4797242.01858487 4002121.61353221,1241910.55433709 -4797228.46255695 4002117.27846764,1241905.58223567 -4797232.68949606 4002113.7782439)),((1241912.96945734 -4797237.79163751 4002125.11376279,1241910.55433709 -4797228.46255695 4002117.27846764,1241907.99734626 -4797242.01858487 4002121.61353221,1241912.96945734 -4797237.79163751 4002125.11376279)),((1241905.55682157 -4797234.25987552 4002131.60367685,1241903.14171574 -4797224.93080186 4002123.76836904,1241910.55433709 -4797228.46255695 4002117.27846764,1241905.55682157 -4797234.25987552 4002131.60367685)),((1241910.55433709 -4797228.46255695 4002117.27846764,1241912.96945734 -4797237.79163751 4002125.11376279,1241905.55682157 -4797234.25987552 4002131.60367685,1241910.55433709 -4797228.46255695 4002117.27846764)),((1241903.14171574 -4797224.93080186 4002123.76836904,1241905.55682157 -4797234.25987552 4002131.60367685,1241911.54902145 -4797217.68794191 4002129.80061267,1241903.14171574 -4797224.93080186 4002123.76836904)),((1241913.96414361 -4797227.01700145 4002137.63593226,1241911.54902145 -4797217.68794191 4002129.80061267,1241905.55682157 -4797234.25987552 4002131.60367685,1241913.96414361 -4797227.01700145 4002137.63593226)),((1241921.3076186 -4797230.52419617 4002131.19658769,1241918.89248214 -4797221.19512978 4002123.36128067,1241911.54902145 -4797217.68794191 4002129.80061267,1241921.3076186 -4797230.52419617 4002131.19658769)),((1241911.54902145 -4797217.68794191 4002129.80061267,1241913.96414361 -4797227.01700145 4002137.63593226,1241921.3076186 -4797230.52419617 4002131.19658769,1241911.54902145 -4797217.68794191 4002129.80061267)))";
        var g = Geometry.Deserialize<WktSerializer>(wkt);

        var surface = (PolyhedralSurface)g;

        var triangles = GeometryProcessor.GetTriangles(surface, 0, new double[] { 0, 0, 0 }, new double[] { 1, 1, 1 });

        var normals = new List<Vector3>();
        var length = new List<double>();
        foreach (var triangle in triangles) {
            normals.Add(triangle.GetNormal().Normalize());
            length.Add(triangle.GetNormal().Normalize().Length());
        }

        var material = new MaterialBuilder().
WithDoubleSide(true).
WithMetallicRoughnessShader().
WithChannelParam(KnownChannel.BaseColor, KnownProperty.RGBA, new Vector4(1, 1, 1, 1));

        var mesh = new MeshBuilder<VertexPositionNormal, VertexWithBatchId, VertexEmpty>("mesh");

        foreach (var triangle in triangles) {
            DrawTriangle(triangle, material, mesh);
        }

        var scene = new SceneBuilder();

        scene.AddRigidMesh(mesh, Matrix4x4.Identity);
        var model = scene.ToGltf2();

        // act
        var outlines = OutlineDetection.GetOutlines(model.LogicalMeshes[0].Primitives[0]);

        // assert
        Assert.That(outlines.Count > 0, Is.True);
    }

    [Test]
    public void PolyAreaWithDuplicateIndicesTest()
    {
        // arrange
        // ogc_fid = 15544
        var wkt = "POLYHEDRALSURFACE Z (((1238016.74734818 -4799154.34602958 4001021.94854933,1238011.42191493 -4799160.05874017 4001016.77890773,1238004.78526014 -4799150.58113141 4001030.11081053,1238016.74734818 -4799154.34602958 4001021.94854933)),((1237999.45974153 -4799156.29385832 4001024.94117579,1238004.78526014 -4799150.58113141 4001030.11081053,1238011.42191493 -4799160.05874017 4001016.77890773,1237999.45974153 -4799156.29385832 4001024.94117579)),((1238018.83311596 -4799162.43147876 4001028.73476214,1238013.50767374 -4799168.144199 4001023.5651118,1238006.87100775 -4799158.6665742 4001036.89703715,1238018.83311596 -4799162.43147876 4001028.73476214)),((1238001.54548018 -4799164.37931076 4001031.72739367,1238006.87100775 -4799158.6665742 4001036.89703715,1238013.50767374 -4799168.144199 4001023.5651118,1238001.54548018 -4799164.37931076 4001031.72739367)),((1238013.50767374 -4799168.144199 4001023.5651118,1238011.42191493 -4799160.05874017 4001016.77890773,1238016.74734818 -4799154.34602958 4001021.94854933,1238013.50767374 -4799168.144199 4001023.5651118)),((1238016.74734818 -4799154.34602958 4001021.94854933,1238018.83311596 -4799162.43147876 4001028.73476214,1238013.50767374 -4799168.144199 4001023.5651118,1238016.74734818 -4799154.34602958 4001021.94854933)),((1238001.54548018 -4799164.37931076 4001031.72739367,1237999.45974153 -4799156.29385832 4001024.94117579,1238011.42191493 -4799160.05874017 4001016.77890773,1238001.54548018 -4799164.37931076 4001031.72739367)),((1238011.42191493 -4799160.05874017 4001016.77890773,1238013.50767374 -4799168.144199 4001023.5651118,1238001.54548018 -4799164.37931076 4001031.72739367,1238011.42191493 -4799160.05874017 4001016.77890773)),((1237999.45974153 -4799156.29385832 4001024.94117579,1238001.54548018 -4799164.37931076 4001031.72739367,1238004.78526014 -4799150.58113141 4001030.11081053,1237999.45974153 -4799156.29385832 4001024.94117579)),((1238006.87100775 -4799158.6665742 4001036.89703715,1238004.78526014 -4799150.58113141 4001030.11081053,1238001.54548018 -4799164.37931076 4001031.72739367,1238006.87100775 -4799158.6665742 4001036.89703715)),((1238004.78526014 -4799150.58113141 4001030.11081053,1238006.87100775 -4799158.6665742 4001036.89703715,1238016.74734818 -4799154.34602958 4001021.94854933,1238004.78526014 -4799150.58113141 4001030.11081053)),((1238018.83311596 -4799162.43147876 4001028.73476214,1238016.74734818 -4799154.34602958 4001021.94854933,1238006.87100775 -4799158.6665742 4001036.89703715,1238018.83311596 -4799162.43147876 4001028.73476214)))";
        var g = Geometry.Deserialize<WktSerializer>(wkt);

        var surface = (PolyhedralSurface)g;
        var triangles = GeometryProcessor.GetTriangles(surface, 0, new double[] { 0, 0, 0 }, new double[] { 1, 1, 1 });
        Assert.That(triangles.Count == 12, Is.True);

        var material = new MaterialBuilder().
            WithDoubleSide(true).
            WithMetallicRoughnessShader().
            WithChannelParam(KnownChannel.BaseColor, KnownProperty.RGBA, new Vector4(1, 1, 1, 1));

        var mesh = new MeshBuilder<VertexPositionNormal, VertexWithBatchId, VertexEmpty>("mesh");

        foreach (var triangle in triangles) {
            DrawTriangle(triangle, material, mesh);
        }

        var scene = new SceneBuilder();

        scene.AddRigidMesh(mesh, Matrix4x4.Identity);
        var model = scene.ToGltf2();

        // act
        var outlines = OutlineDetection.GetOutlines(model.LogicalMeshes[0].Primitives[0]);

        // assert
        Assert.That(outlines.Count > 0, Is.True);
    }

    [Test]
    public void Polygon5812Test()
    {
        // arrange
        var wkt = "POLYHEDRALSURFACE Z (((-1085.6930126023944 -3333.6535406727344 -4819.485265350901,-1078.8289817469195 -3333.5242771124467 -4821.439057455398,-1087.7491943775676 -3342.2058568587527 -4829.042992391158,-1085.6930126023944 -3333.6535406727344 -4819.485265350901)),((-1081.9425674220547 -3342.0964868245646 -4830.695779501926,-1087.7491943775676 -3342.2058568587527 -4829.042992391158,-1078.8289817469195 -3333.5242771124467 -4821.439057455398,-1081.9425674220547 -3342.0964868245646 -4830.695779501926)),((-1083.0550515097566 -3343.888195139356 -4810.894723505247,-1076.1910060127266 -3343.7589313173667 -4812.84851979278,-1085.1112376530655 -3352.440529628657 -4820.452471010387,-1083.0550515097566 -3343.888195139356 -4810.894723505247)),((-1079.3045983116608 -3352.3311593737453 -4822.105261660181,-1085.1112376530655 -3352.440529628657 -4820.452471010387,-1076.1910060127266 -3343.7589313173667 -4812.84851979278,-1079.3045983116608 -3352.3311593737453 -4822.105261660181)),((-1085.6930126023944 -3333.6535406727344 -4819.485265350901,-1083.0550515097566 -3343.888195139356 -4810.894723505247,-1078.8289817469195 -3333.5242771124467 -4821.439057455398,-1085.6930126023944 -3333.6535406727344 -4819.485265350901)),((-1076.1910060127266 -3343.7589313173667 -4812.84851979278,-1078.8289817469195 -3333.5242771124467 -4821.439057455398,-1083.0550515097566 -3343.888195139356 -4810.894723505247,-1076.1910060127266 -3343.7589313173667 -4812.84851979278)),((-1079.3045983116608 -3352.3311593737453 -4822.105261660181,-1081.9425674220547 -3342.0964868245646 -4830.695779501926,-1078.8289817469195 -3333.5242771124467 -4821.439057455398,-1079.3045983116608 -3352.3311593737453 -4822.105261660181)),((-1078.8289817469195 -3333.5242771124467 -4821.439057455398,-1076.1910060127266 -3343.7589313173667 -4812.84851979278,-1079.3045983116608 -3352.3311593737453 -4822.105261660181,-1078.8289817469195 -3333.5242771124467 -4821.439057455398)),((-1085.1112376530655 -3352.440529628657 -4820.452471010387,-1087.7491943775676 -3342.2058568587527 -4829.042992391158,-1081.9425674220547 -3342.0964868245646 -4830.695779501926,-1085.1112376530655 -3352.440529628657 -4820.452471010387)),((-1081.9425674220547 -3342.0964868245646 -4830.695779501926,-1079.3045983116608 -3352.3311593737453 -4822.105261660181,-1085.1112376530655 -3352.440529628657 -4820.452471010387,-1081.9425674220547 -3342.0964868245646 -4830.695779501926)),((-1087.7491943775676 -3342.2058568587527 -4829.042992391158,-1085.1112376530655 -3352.440529628657 -4820.452471010387,-1085.6930126023944 -3333.6535406727344 -4819.485265350901,-1087.7491943775676 -3342.2058568587527 -4829.042992391158)),((-1083.0550515097566 -3343.888195139356 -4810.894723505247,-1085.6930126023944 -3333.6535406727344 -4819.485265350901,-1085.1112376530655 -3352.440529628657 -4820.452471010387,-1083.0550515097566 -3343.888195139356 -4810.894723505247)))";
        var g = (PolyhedralSurface)Geometry.Deserialize<WktSerializer>(wkt);
        var triangles = GeometryProcessor.GetTriangles(g, 0);

        // act
        var res = OutlineDetection.GetOutlines2(triangles);

        // assert
        Assert.That(res.Count == 48, Is.True);
    }

    [Test]
    public void MultiPolygonZTest()
    {
        // arrange
        var wkt = "MULTIPOLYGON Z (((-1078.8289817469195 -3333.5242771124467 -4821.439057455398,-1073.1848455679137 -3333.418020649813 -4823.045666193124,-1081.9425674220547 -3342.0964868245646 -4830.695779501926,-1078.8289817469195 -3333.5242771124467 -4821.439057455398)),((-1075.7065515371505 -3341.979115477763 -4832.470900063869,-1081.9425674220547 -3342.0964868245646 -4830.695779501926,-1073.1848455679137 -3333.418020649813 -4823.045666193124,-1075.7065515371505 -3341.979115477763 -4832.470900063869)),((-1076.2219954489265 -3343.6387004302815 -4812.949436534662,-1070.5778473715764 -3343.5324437553063 -4814.556048672646,-1079.3355876698624 -3352.2109282715246 -4822.206178169232,-1076.2219954489265 -3343.6387004302815 -4812.949436534662)),((-1073.0995586388744 -3352.09355669003 -4823.981302487664,-1079.3355876698624 -3352.2109282715246 -4822.206178169232,-1070.5778473715764 -3343.5324437553063 -4814.556048672646,-1073.0995586388744 -3352.09355669003 -4823.981302487664)),((-1078.8289817469195 -3333.5242771124467 -4821.439057455398,-1076.2219954489265 -3343.6387004302815 -4812.949436534662,-1073.1848455679137 -3333.418020649813 -4823.045666193124,-1078.8289817469195 -3333.5242771124467 -4821.439057455398)),((-1070.5778473715764 -3343.5324437553063 -4814.556048672646,-1073.1848455679137 -3333.418020649813 -4823.045666193124,-1076.2219954489265 -3343.6387004302815 -4812.949436534662,-1070.5778473715764 -3343.5324437553063 -4814.556048672646)),((-1073.0995586388744 -3352.09355669003 -4823.981302487664,-1075.7065515371505 -3341.979115477763 -4832.470900063869,-1073.1848455679137 -3333.418020649813 -4823.045666193124,-1073.0995586388744 -3352.09355669003 -4823.981302487664)),((-1073.1848455679137 -3333.418020649813 -4823.045666193124,-1070.5778473715764 -3343.5324437553063 -4814.556048672646,-1073.0995586388744 -3352.09355669003 -4823.981302487664,-1073.1848455679137 -3333.418020649813 -4823.045666193124)),((-1079.3355876698624 -3352.2109282715246 -4822.206178169232,-1081.9425674220547 -3342.0964868245646 -4830.695779501926,-1075.7065515371505 -3341.979115477763 -4832.470900063869,-1079.3355876698624 -3352.2109282715246 -4822.206178169232)),((-1075.7065515371505 -3341.979115477763 -4832.470900063869,-1073.0995586388744 -3352.09355669003 -4823.981302487664,-1079.3355876698624 -3352.2109282715246 -4822.206178169232,-1075.7065515371505 -3341.979115477763 -4832.470900063869)),((-1081.9425674220547 -3342.0964868245646 -4830.695779501926,-1079.3355876698624 -3352.2109282715246 -4822.206178169232,-1078.8289817469195 -3333.5242771124467 -4821.439057455398,-1081.9425674220547 -3342.0964868245646 -4830.695779501926)),((-1076.2219954489265 -3343.6387004302815 -4812.949436534662,-1078.8289817469195 -3333.5242771124467 -4821.439057455398,-1079.3355876698624 -3352.2109282715246 -4822.206178169232,-1076.2219954489265 -3343.6387004302815 -4812.949436534662)))";
        var g = (MultiPolygon)Geometry.Deserialize<WktSerializer>(wkt);
        var triangles = GeometryProcessor.GetTriangles(g, 0);

        // act
        var res = OutlineDetection.GetOutlines2(triangles);

        // assert
        Assert.That(res.Count == 48, Is.True);
    }


    [Test]
    public void Polygon5811Test()
    {
        // arrange
        var wkt = "POLYHEDRALSURFACE Z (((-1078.8289817469195 -3333.5242771124467 -4821.439057455398,-1073.1848455679137 -3333.418020649813 -4823.045666193124,-1081.9425674220547 -3342.0964868245646 -4830.695779501926,-1078.8289817469195 -3333.5242771124467 -4821.439057455398)),((-1075.7065515371505 -3341.979115477763 -4832.470900063869,-1081.9425674220547 -3342.0964868245646 -4830.695779501926,-1073.1848455679137 -3333.418020649813 -4823.045666193124,-1075.7065515371505 -3341.979115477763 -4832.470900063869)),((-1076.2219954489265 -3343.6387004302815 -4812.949436534662,-1070.5778473715764 -3343.5324437553063 -4814.556048672646,-1079.3355876698624 -3352.2109282715246 -4822.206178169232,-1076.2219954489265 -3343.6387004302815 -4812.949436534662)),((-1073.0995586388744 -3352.09355669003 -4823.981302487664,-1079.3355876698624 -3352.2109282715246 -4822.206178169232,-1070.5778473715764 -3343.5324437553063 -4814.556048672646,-1073.0995586388744 -3352.09355669003 -4823.981302487664)),((-1078.8289817469195 -3333.5242771124467 -4821.439057455398,-1076.2219954489265 -3343.6387004302815 -4812.949436534662,-1073.1848455679137 -3333.418020649813 -4823.045666193124,-1078.8289817469195 -3333.5242771124467 -4821.439057455398)),((-1070.5778473715764 -3343.5324437553063 -4814.556048672646,-1073.1848455679137 -3333.418020649813 -4823.045666193124,-1076.2219954489265 -3343.6387004302815 -4812.949436534662,-1070.5778473715764 -3343.5324437553063 -4814.556048672646)),((-1073.0995586388744 -3352.09355669003 -4823.981302487664,-1075.7065515371505 -3341.979115477763 -4832.470900063869,-1073.1848455679137 -3333.418020649813 -4823.045666193124,-1073.0995586388744 -3352.09355669003 -4823.981302487664)),((-1073.1848455679137 -3333.418020649813 -4823.045666193124,-1070.5778473715764 -3343.5324437553063 -4814.556048672646,-1073.0995586388744 -3352.09355669003 -4823.981302487664,-1073.1848455679137 -3333.418020649813 -4823.045666193124)),((-1079.3355876698624 -3352.2109282715246 -4822.206178169232,-1081.9425674220547 -3342.0964868245646 -4830.695779501926,-1075.7065515371505 -3341.979115477763 -4832.470900063869,-1079.3355876698624 -3352.2109282715246 -4822.206178169232)),((-1075.7065515371505 -3341.979115477763 -4832.470900063869,-1073.0995586388744 -3352.09355669003 -4823.981302487664,-1079.3355876698624 -3352.2109282715246 -4822.206178169232,-1075.7065515371505 -3341.979115477763 -4832.470900063869)),((-1081.9425674220547 -3342.0964868245646 -4830.695779501926,-1079.3355876698624 -3352.2109282715246 -4822.206178169232,-1078.8289817469195 -3333.5242771124467 -4821.439057455398,-1081.9425674220547 -3342.0964868245646 -4830.695779501926)),((-1076.2219954489265 -3343.6387004302815 -4812.949436534662,-1078.8289817469195 -3333.5242771124467 -4821.439057455398,-1079.3355876698624 -3352.2109282715246 -4822.206178169232,-1076.2219954489265 -3343.6387004302815 -4812.949436534662)))";
        var g = (PolyhedralSurface)Geometry.Deserialize<WktSerializer>(wkt);
        var triangles = GeometryProcessor.GetTriangles(g, 0);

        // act
        var res = OutlineDetection.GetOutlines2(triangles);

        // assert
        Assert.That(res.Count == 48, Is.True);
    }

    [Test]
    public void FindConnectedTrianglesWithSameNormal()
    {
        // arrange
        var t0 = new Triangle(new Point(0, 0, 0), new Point(0, 1, 0), new Point(1, 0, 0), 0);
        var t1 = new Triangle(new Point(1, 0, 0), new Point(1, 1, 0), new Point(2, 0, 0), 0);
        var t2 = new Triangle(new Point(1, 0, 0), new Point(0, 1, 0), new Point(1, 1, 0), 0);

        var triangles = new List<Triangle> { t0, t1, t2 };

        var a = Adjacency.GetAdjacencyList(triangles);
        Assert.That(a.ContainsKey(0), Is.True);
        Assert.That(a[0].Count == 1, Is.True);
        Assert.That(a[1].Count == 1, Is.True);
        Assert.That(a[2].Count == 2, Is.True);


        var outlines = Part.GetOutlines(triangles, new List<uint>() { 0, 1, 2 });
        Assert.That(outlines[0] == 0, Is.True);
        Assert.That(outlines[1] == 1, Is.True);
        Assert.That(outlines[2] == 2, Is.True);
        Assert.That(outlines[3] == 0, Is.True);
        Assert.That(outlines[4] == 4, Is.True);
        Assert.That(outlines[5] == 5, Is.True);
        Assert.That(outlines[6] == 5, Is.True);
        Assert.That(outlines[7] == 3, Is.True);
        Assert.That(outlines[8] == 7, Is.True);
        Assert.That(outlines[9] == 8, Is.True);
    }

    [Test]
    public void MissingOutlineBetweenRoofAndWallTest()
    {
        // Test case from @bertt - outlines missing between roof and wall
        // This geometry has a flat roof and vertical walls
        var wkt = "MULTIPOLYGON Z (((996641.926566 6414111.970704 1680.94,996641.978211 6414111.995079 1680.94,996646.698807 6414111.800273 1680.94,996652.310527 6414111.405804 1680.94,996652.393401 6414111.349871 1680.94,996652.545348 6414107.233893 1680.94,996652.694588 6414102.887034 1680.94,996652.666735 6414102.83326 1680.94,996652.612954 6414102.805422 1680.94,996641.364935 6414103.206013 1680.94,996641.321058 6414103.245814 1680.94,996641.3074 6414103.303457 1680.94,996641.616039 6414107.831779 1680.94,996641.893525 6414111.903023 1680.94,996641.926566 6414111.970704 1680.94)),((996652.545348 6414107.233893 1697.167989,996652.545348 6414107.233893 1680.94,996652.393401 6414111.349871 1680.94,996652.393401 6414111.349871 1694.421382,996652.545348 6414107.233893 1697.167989)),((996646.698807 6414111.800273 1694.368798,996646.698807 6414111.800273 1680.94,996641.978211 6414111.995079 1680.94,996641.978211 6414111.995079 1694.444648,996646.698807 6414111.800273 1694.368798)),((996652.393401 6414111.349871 1694.421382,996652.393401 6414111.349871 1680.94,996652.310527 6414111.405804 1680.94,996652.310527 6414111.405804 1694.387587,996652.393401 6414111.349871 1694.421382)),((996652.310527 6414111.405804 1694.387587,996652.310527 6414111.405804 1680.94,996646.698807 6414111.800273 1680.94,996646.698807 6414111.800273 1694.368798,996652.310527 6414111.405804 1694.387587)),((996652.694588 6414102.887034 1694.138709,996652.694588 6414102.887034 1680.94,996652.545348 6414107.233893 1680.94,996652.545348 6414107.233893 1697.167989,996652.694588 6414102.887034 1694.138709)),((996641.321058 6414103.245814 1694.035381,996641.321058 6414103.245814 1680.94,996641.364935 6414103.206013 1680.94,996641.364935 6414103.206013 1694.008966,996641.321058 6414103.245814 1694.035381)),((996641.3074 6414103.303457 1694.075188,996641.3074 6414103.303457 1680.94,996641.321058 6414103.245814 1680.94,996641.321058 6414103.245814 1694.035381,996641.3074 6414103.303457 1694.075188)),((996652.612954 6414102.805422 1694.079209,996652.612954 6414102.805422 1680.94,996652.666735 6414102.83326 1680.94,996652.666735 6414102.83326 1694.100311,996652.612954 6414102.805422 1694.079209)),((996641.364935 6414103.206013 1694.008966,996641.364935 6414103.206013 1680.94,996652.612954 6414102.805422 1680.94,996652.612954 6414102.805422 1694.079209,996641.364935 6414103.206013 1694.008966)),((996652.666735 6414102.83326 1694.100311,996652.666735 6414102.83326 1680.94,996652.694588 6414102.887034 1680.94,996652.694588 6414102.887034 1694.138709,996652.666735 6414102.83326 1694.100311)),((996641.616039 6414107.831779 1697.245363,996641.616039 6414107.831779 1680.94,996641.3074 6414103.303457 1680.94,996641.3074 6414103.303457 1694.075188,996641.616039 6414107.831779 1697.245363)),((996641.926566 6414111.970704 1694.46321,996641.926566 6414111.970704 1680.94,996641.893525 6414111.903023 1680.94,996641.893525 6414111.903023 1694.509925,996641.926566 6414111.970704 1694.46321)),((996641.893525 6414111.903023 1694.509925,996641.893525 6414111.903023 1680.94,996641.616039 6414107.831779 1680.94,996641.616039 6414107.831779 1697.245363,996641.893525 6414111.903023 1694.509925)),((996641.978211 6414111.995079 1694.444648,996641.978211 6414111.995079 1680.94,996641.926566 6414111.970704 1680.94,996641.926566 6414111.970704 1694.46321,996641.978211 6414111.995079 1694.444648)),((996641.616039 6414107.831779 1697.245363,996641.3074 6414103.303457 1694.075188,996641.321058 6414103.245814 1694.035381,996641.364935 6414103.206013 1694.008966,996652.612954 6414102.805422 1694.079209,996652.666735 6414102.83326 1694.100311,996652.694588 6414102.887034 1694.138709,996652.545348 6414107.233893 1697.167989,996641.616039 6414107.831779 1697.245363)),((996641.978211 6414111.995079 1694.444648,996641.926566 6414111.970704 1694.46321,996641.893525 6414111.903023 1694.509925,996641.616039 6414107.831779 1697.245363,996652.545348 6414107.233893 1697.167989,996652.393401 6414111.349871 1694.421382,996652.310527 6414111.405804 1694.387587,996646.698807 6414111.800273 1694.368798,996641.978211 6414111.995079 1694.444648)))";
        
        var g = (MultiPolygon)Geometry.Deserialize<WktSerializer>(wkt);
        var triangles = GeometryProcessor.GetTriangles(g, 0);

        // Print normals of ALL triangles to understand the geometry
        System.Console.WriteLine("Triangle normals (all triangles):");
        for (var i = 0; i < triangles.Count; i++) {
            var normal = triangles[i].GetNormal();
            var points = triangles[i].GetPoints();
            var maxZ = System.Math.Max(points[0].Z ?? 0, System.Math.Max(points[1].Z ?? 0, points[2].Z ?? 0));
            var minZ = System.Math.Min(points[0].Z ?? 0, System.Math.Min(points[1].Z ?? 0, points[2].Z ?? 0));
            var type = System.Math.Abs(normal.Z) > 0.7 ? "FLOOR/ROOF" : "WALL";
            System.Console.WriteLine($"  Tri {i,2}: normal=({normal.X:F3}, {normal.Y:F3}, {normal.Z:F3}), z=[{minZ:F1}, {maxZ:F1}] {type}");
        }

        // act
        var parts = PartFinder.GetParts(triangles);
        
        // Check that we have multiple parts (roof should be separate from walls)
        Assert.That(parts.Count > 1, Is.True, "Should have multiple parts for roof and walls");
        
        // Find the roof part (horizontal faces with z-normal)
        // and wall parts (vertical faces)
        var roofPartIndices = new List<int>();
        var wallPartIndices = new List<int>();
        
        for (var i = 0; i < parts.Count; i++) {
            var partTriangles = Triangles.SelectByIndex(triangles, parts[i]);
            if (partTriangles.Count > 0) {
                var normal = partTriangles[0].GetNormal();
                // Check if mostly pointing up (roof) or horizontal (wall)
                if (System.Math.Abs(normal.Z) > 0.7) {
                    roofPartIndices.Add(i);
                } else {
                    wallPartIndices.Add(i);
                }
            }
        }
        
        System.Console.WriteLine($"Number of triangles: {triangles.Count}");
        System.Console.WriteLine($"Number of parts: {parts.Count}");
        
        // Print which triangles are in which parts
        System.Console.WriteLine("\nPart membership:");
        for (var i = 0; i < parts.Count; i++) {
            var partTriList = parts[i];
            System.Console.WriteLine($"  Part {i}: triangles [{string.Join(", ", partTriList)}]");
        }
        
        System.Console.WriteLine($"Roof parts: {roofPartIndices.Count}");
        System.Console.WriteLine($"Wall parts: {wallPartIndices.Count}");
        
        // Now check if edges between roof and walls are detected
        // For now, just verify structure is correct
        Assert.That(roofPartIndices.Count > 0, Is.True, "Should have at least one roof part");
        Assert.That(wallPartIndices.Count > 0, Is.True, "Should have at least one wall part");
        
        var outlines = OutlineDetection.GetOutlines2(triangles);
        System.Console.WriteLine($"Number of outline indices: {outlines.Count}");
        
        // Check if the roof-wall boundary edges are in the outlines
        // The boundary should be edges at the top of walls connecting to bottom of roof
        // Let's check if any outline edges connect triangles from different parts
        
        // Get all unique edges in the outlines
        var outlineEdges = new HashSet<string>();
        for (var i = 0; i < outlines.Count; i += 2) {
            var v1 = outlines[i];
            var v2 = outlines[i + 1];
            var edge = v1 < v2 ? $"{v1}-{v2}" : $"{v2}-{v1}";
            outlineEdges.Add(edge);
        }
        
        System.Console.WriteLine($"\nTotal unique outline edges: {outlineEdges.Count}");
        
        // Now check which edges are between roof and wall triangles
        var roofWallBoundaryEdges = 0;
        var roofTriSet = new HashSet<int>(Enumerable.Range(40, 12));
        var wallTriSet = new HashSet<int>(Enumerable.Range(12, 28));
        
        // Check each triangle's edges
        for (var i = 0; i < triangles.Count; i++) {
            var isRoof = roofTriSet.Contains(i);
            var isWall = wallTriSet.Contains(i);
            
            if (isRoof || isWall) {
                // Check edges of this triangle
                var offset = (uint)(i * 3);
                var edges = new[] {
                    (offset, offset + 1),
                    (offset + 1, offset + 2),
                    (offset + 2, offset)
                };
                
                foreach (var (v1, v2) in edges) {
                    var edge = v1 < v2 ? $"{v1}-{v2}" : $"{v2}-{v1}";
                    if (outlineEdges.Contains(edge)) {
                        // This edge is in the outlines - check if it's at roof-wall boundary
                        var points = triangles[i].GetPoints();
                        var z1 = v1 % 3 == 0 ? points[0].Z : (v1 % 3 == 1 ? points[1].Z : points[2].Z);
                        var z2 = v2 % 3 == 0 ? points[0].Z : (v2 % 3 == 1 ? points[1].Z : points[2].Z);
                        
                        // Check if both vertices are at roof level (z > 1694)
                        if (z1 > 1694 && z2 > 1694) {
                            if ((isRoof && z1 < 1695 && z2 < 1695) || (isWall)) {
                                roofWallBoundaryEdges++;
                                if (roofWallBoundaryEdges <= 3) {
                                    System.Console.WriteLine($"  Roof-wall boundary edge found: tri {i}, edge {edge}, z=[{z1:F1}, {z2:F1}]");
                                }
                            }
                        }
                    }
                }
            }
        }
        
        System.Console.WriteLine($"Roof-wall boundary edges found: {roofWallBoundaryEdges}");
        
        // Check for duplicate edges in outlines (edges that appear more than once)
        var edgeCounts = new Dictionary<string, int>();
        for (var i = 0; i < outlines.Count; i += 2) {
            var v1 = outlines[i];
            var v2 = outlines[i + 1];
            var edge = v1 < v2 ? $"{v1}-{v2}" : $"{v2}-{v1}";
            if (!edgeCounts.ContainsKey(edge)) {
                edgeCounts[edge] = 0;
            }
            edgeCounts[edge]++;
        }
        
        var duplicateEdges = edgeCounts.Where(kvp => kvp.Value > 1).ToList();
        System.Console.WriteLine($"\nEdges appearing multiple times in outlines: {duplicateEdges.Count}");
        if (duplicateEdges.Count > 0 && duplicateEdges.Count <= 5) {
            foreach (var dup in duplicateEdges) {
                System.Console.WriteLine($"  Edge {dup.Key} appears {dup.Value} times");
            }
        }
        
        // The test should verify that outlines exist at the roof-wall boundary
        // We expect many boundary edges since the perimeter is made of many triangle edges
        Assert.That(roofWallBoundaryEdges, Is.GreaterThan(20), 
            $"Should have many outline edges at roof-wall boundary, but found only {roofWallBoundaryEdges}");
        Assert.That(outlines.Count, Is.GreaterThan(0));
    }

    [Test]
    public void OutlinesBetweenDifferentNormalPartsTest()
    {
        // Simple test: A box with a horizontal top and vertical sides
        // Top face (2 triangles with normal pointing up)
        var top1 = new Triangle(new Point(0, 0, 1), new Point(1, 0, 1), new Point(0, 1, 1), 0);
        var top2 = new Triangle(new Point(1, 0, 1), new Point(1, 1, 1), new Point(0, 1, 1), 1);
        
        // Front wall (2 triangles with normal pointing forward)
        var front1 = new Triangle(new Point(0, 0, 0), new Point(1, 0, 0), new Point(0, 0, 1), 2);
        var front2 = new Triangle(new Point(1, 0, 0), new Point(1, 0, 1), new Point(0, 0, 1), 3);
        
        var triangles = new List<Triangle> { top1, top2, front1, front2 };
        
        // act
        var parts = PartFinder.GetParts(triangles);
        
        // Should have 2 parts: one for top, one for front
        Assert.That(parts.Count, Is.EqualTo(2));
        
        var outlines = OutlineDetection.GetOutlines2(triangles);
        
        System.Console.WriteLine($"Number of parts: {parts.Count}");
        System.Console.WriteLine($"Number of outline indices: {outlines.Count}");
        
        // Top part: 2 triangles sharing 1 edge = 4 outline edges = 8 indices
        // Front part: 2 triangles sharing 1 edge = 4 outline edges = 8 indices
        // Total: 16 indices
        Assert.That(outlines.Count, Is.EqualTo(16));
    }

    [Test]
    public void RoofWallBoundaryOutlinesShouldExist()
    {
        // Simpler test: Create a box with walls and a sloped roof
        // The horizontal perimeter between wall tops and roof bottom should have outlines
        
        // Floor (one triangle at z=0)
        var floor = new Triangle(new Point(0, 0, 0), new Point(10, 0, 0), new Point(0, 10, 0), 0);
        
        // Front wall (vertical, from z=0 to z=5)
        var wall1 = new Triangle(new Point(0, 0, 0), new Point(10, 0, 0), new Point(0, 0, 5), 1);
        var wall2 = new Triangle(new Point(10, 0, 0), new Point(10, 0, 5), new Point(0, 0, 5), 2);
        
        // Roof (sloped, starting at z=5 on front, going to z=7 at back)
        var roof1 = new Triangle(new Point(0, 0, 5), new Point(10, 0, 5), new Point(0, 10, 7), 3);
        var roof2 = new Triangle(new Point(10, 0, 5), new Point(10, 10, 7), new Point(0, 10, 7), 4);
        
        var triangles = new List<Triangle> { floor, wall1, wall2, roof1, roof2 };
        
        // Get parts and outlines
        var parts = PartFinder.GetParts(triangles);
        var outlines = OutlineDetection.GetOutlines2(triangles);
        
        System.Console.WriteLine($"\nSimple roof-wall test:");
        System.Console.WriteLine($"  Triangles: {triangles.Count}");
        System.Console.WriteLine($"  Parts: {parts.Count}");
        System.Console.WriteLine($"  Outline indices: {outlines.Count}");
        
        // The edge between wall2 and roof1 at (0,0,5)-(10,0,5) should be in outlines
        // wall2 has vertices: (10,0,0), (10,0,5), (0,0,5) -> indices 6,7,8
        // roof1 has vertices: (0,0,5), (10,0,5), (0,10,7) -> indices 9,10,11
        // The shared edge is (0,0,5)-(10,0,5) which is vertices 8-7 in wall2 and 9-10 in roof1
        
        // Check if edge 7-8 is in outlines (from wall2)
        var hasWallEdge = false;
        var hasRoofEdge = false;
        for (var i = 0; i < outlines.Count; i += 2) {
            var v1 = outlines[i];
            var v2 = outlines[i + 1];
            if ((v1 == 7 && v2 == 8) || (v1 == 8 && v2 == 7)) {
                hasWallEdge = true;
                System.Console.WriteLine($"  Found wall edge 7-8 at roof level");
            }
            if ((v1 == 9 && v2 == 10) || (v1 == 10 && v2 == 9)) {
                hasRoofEdge = true;
                System.Console.WriteLine($"  Found roof edge 9-10 at wall top level");
            }
        }
        
        Assert.That(hasWallEdge || hasRoofEdge, Is.True, 
            "Should have outline edge at the boundary between wall top and roof base");
    }

    [Test]
    public void SimpleTestBuildingOutlineCount()
    {
        // Create a simple test building similar to the one shown in the issue images
        // A rectangular box with floor, 4 walls, and a simple roof
        
        var triangles = new List<Triangle>();
        
        // Floor (2 triangles forming a rectangle at z=0)
        triangles.Add(new Triangle(new Point(0, 0, 0), new Point(10, 0, 0), new Point(0, 10, 0), 0));
        triangles.Add(new Triangle(new Point(10, 0, 0), new Point(10, 10, 0), new Point(0, 10, 0), 1));
        
        // Front wall (2 triangles, z=0 to z=5)
        triangles.Add(new Triangle(new Point(0, 0, 0), new Point(10, 0, 0), new Point(0, 0, 5), 2));
        triangles.Add(new Triangle(new Point(10, 0, 0), new Point(10, 0, 5), new Point(0, 0, 5), 3));
        
        // Back wall (2 triangles, z=0 to z=5)
        triangles.Add(new Triangle(new Point(0, 10, 0), new Point(0, 10, 5), new Point(10, 10, 0), 4));
        triangles.Add(new Triangle(new Point(10, 10, 0), new Point(0, 10, 5), new Point(10, 10, 5), 5));
        
        // Left wall (2 triangles, z=0 to z=5)
        triangles.Add(new Triangle(new Point(0, 0, 0), new Point(0, 0, 5), new Point(0, 10, 0), 6));
        triangles.Add(new Triangle(new Point(0, 10, 0), new Point(0, 0, 5), new Point(0, 10, 5), 7));
        
        // Right wall (2 triangles, z=0 to z=5)
        triangles.Add(new Triangle(new Point(10, 0, 0), new Point(10, 10, 0), new Point(10, 0, 5), 8));
        triangles.Add(new Triangle(new Point(10, 10, 0), new Point(10, 10, 5), new Point(10, 0, 5), 9));
        
        // Flat roof (2 triangles at z=5)
        triangles.Add(new Triangle(new Point(0, 0, 5), new Point(10, 0, 5), new Point(0, 10, 5), 10));
        triangles.Add(new Triangle(new Point(10, 0, 5), new Point(10, 10, 5), new Point(0, 10, 5), 11));
        
        var parts = PartFinder.GetParts(triangles);
        var outlines = OutlineDetection.GetOutlines2(triangles);
        
        // Count unique edges
        var uniqueEdges = new HashSet<string>();
        for (var i = 0; i < outlines.Count; i += 2) {
            var v1 = outlines[i];
            var v2 = outlines[i + 1];
            var edge = v1 < v2 ? $"{v1}-{v2}" : $"{v2}-{v1}";
            uniqueEdges.Add(edge);
        }
        
        System.Console.WriteLine($"\nSimple test building:");
        System.Console.WriteLine($"  Triangles: {triangles.Count}");
        System.Console.WriteLine($"  Parts: {parts.Count}");
        System.Console.WriteLine($"  Outline indices: {outlines.Count}");
        System.Console.WriteLine($"  Unique outline edges: {uniqueEdges.Count}");
        
        Assert.That(uniqueEdges.Count, Is.GreaterThan(0));
        
        // Check if this equals 15 or close to it
        if (uniqueEdges.Count == 15) {
            System.Console.WriteLine("  ✓ Test building has exactly 15 outline edges!");
        } else {
            System.Console.WriteLine($"  Note: Test building has {uniqueEdges.Count} outline edges, not 15");
        }
    }

    [Test]
    public void TestBuildingFromB3dmWriterShouldHave15Lines()
    {
        // This is the actual "testbuilding" from B3dmWriterTests
        // Structure: 1 floor (7-sided) + 4 walls + 1 roof
        // Expected: 7 floor edges + 7 roof edges + 1 vertical edge = 15 lines
        
        var wkt = "MULTIPOLYGON Z (((133836.921875 463013.96875 -2.280999898910522,133842.046875 463004.65625 -2.280999898910522,133833.359375 462999.84375 -2.280999898910522,133831.21875 462998.65625 -2.280999898910522,133830.484375 463000 -2.280999898910522,133826.078125 463008.03125 -2.280999898910522,133828.03125 463009.09375 -2.280999898910522,133836.921875 463013.96875 -2.280999898910522)),((133833.359375 462999.84375 2.655999898910522,133833.359375 462999.84375 -2.280999898910522,133842.046875 463004.65625 -2.280999898910522,133842.046875 463004.65625 -0.250999987125397,133833.359375 462999.84375 2.655999898910522)),((133831.21875 462998.65625 0.360000014305115,133831.21875 462998.65625 -2.280999898910522,133833.359375 462999.84375 -2.280999898910522,133833.359375 462999.84375 2.655999898910522,133833.359375 462999.84375 2.776999950408936,133831.21875 462998.65625 0.360000014305115)),((133828.03125 463009.09375 2.638000011444092,133828.03125 463009.09375 2.555000066757202,133830.1875 463005.34375 2.644999980926514,133828.03125 463009.09375 2.638000011444092)),((133833.359375 462999.84375 2.776999950408936,133833.359375 462999.84375 2.655999898910522,133830.1875 463005.34375 2.644999980926514,133833.359375 462999.84375 2.776999950408936)),((133836.921875 463013.96875 -0.331999987363815,133836.921875 463013.96875 -2.280999898910522,133828.03125 463009.09375 -2.280999898910522,133828.03125 463009.09375 2.555000066757202,133828.03125 463009.09375 2.638000011444092,133836.921875 463013.96875 -0.331999987363815)),((133830.484375 463000 0.358999997377396,133830.484375 463000 -2.280999898910522,133831.21875 462998.65625 -2.280999898910522,133831.21875 462998.65625 0.360000014305115,133830.484375 463000 0.358999997377396)),((133842.046875 463004.65625 -0.250999987125397,133842.046875 463004.65625 -2.280999898910522,133836.921875 463013.96875 -2.280999898910522,133836.921875 463013.96875 -0.331999987363815,133842.046875 463004.65625 -0.250999987125397)),((133826.078125 463008.03125 0.354000002145767,133826.078125 463008.03125 -2.280999898910522,133830.484375 463000 -2.280999898910522,133830.484375 463000 0.358999997377396,133826.078125 463008.03125 0.354000002145767)),((133828.03125 463009.09375 2.555000066757202,133828.03125 463009.09375 -2.280999898910522,133826.078125 463008.03125 -2.280999898910522,133826.078125 463008.03125 0.354000002145767,133828.03125 463009.09375 2.555000066757202)),((133842.046875 463004.65625 -0.250999987125397,133836.921875 463013.96875 -0.331999987363815,133828.03125 463009.09375 2.638000011444092,133830.1875 463005.34375 2.644999980926514,133833.359375 462999.84375 2.655999898910522,133842.046875 463004.65625 -0.250999987125397)),((133828.03125 463009.09375 2.555000066757202,133826.078125 463008.03125 0.354000002145767,133830.484375 463000 0.358999997377396,133831.21875 462998.65625 0.360000014305115,133833.359375 462999.84375 2.776999950408936,133830.1875 463005.34375 2.644999980926514,133828.03125 463009.09375 2.555000066757202)))";
        
        var g = (MultiPolygon)Geometry.Deserialize<WktSerializer>(wkt);
        var triangles = GeometryProcessor.GetTriangles(g, 0);
        
        var parts = PartFinder.GetParts(triangles);
        var outlines = OutlineDetection.GetOutlines2(triangles);
        
        // Count unique edges
        var uniqueEdges = new HashSet<string>();
        for (var i = 0; i < outlines.Count; i += 2) {
            var v1 = outlines[i];
            var v2 = outlines[i + 1];
            var edge = v1 < v2 ? $"{v1}-{v2}" : $"{v2}-{v1}";
            uniqueEdges.Add(edge);
        }
        
        System.Console.WriteLine($"\nTestBuilding from B3dmWriterTests:");
        System.Console.WriteLine($"  Polygons: 1 floor + 4 walls + 1 roof (triangulated into 12 polys in WKT)");
        System.Console.WriteLine($"  Triangles after processing: {triangles.Count}");
        System.Console.WriteLine($"  Parts: {parts.Count}");
        System.Console.WriteLine($"  Outline indices: {outlines.Count}");
        System.Console.WriteLine($"  Unique outline edges: {uniqueEdges.Count}");
        
        // The building has a 7-sided floor, so we expect:
        // - 7 bottom perimeter edges
        // - 7 top perimeter edges  
        // - 1 vertical edge (at gap between walls)
        // Total: 15 edges
        Assert.That(uniqueEdges.Count, Is.EqualTo(15), 
            $"TestBuilding should have exactly 15 outline edges (7 floor + 7 roof + 1 vertical), but has {uniqueEdges.Count}");
    }

}
